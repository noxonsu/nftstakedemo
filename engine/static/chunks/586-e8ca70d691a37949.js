"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[586],{81586:function(t,e,r){r.d(e,{vU:function(){return w}});var n=r(19485),s=r(2593),i=r(16441),o=r(38197),a=r(29251);function c(t){return(0,o.w)((0,a.Y0)(t))}var h=r(6881),u=r(65206),g=r(11388),d=r(1581),l=r(95851);const p=new d.Yd(l.i);class m extends h.dk{}class f extends h.dk{}class E extends h.dk{}class y extends h.dk{static isIndexed(t){return!(!t||!t._isIndexed)}}const v={"0x08c379a0":{signature:"Error(string)",name:"Error",inputs:["string"],reason:!0},"0x4e487b71":{signature:"Panic(uint256)",name:"Panic",inputs:["uint256"]}};function b(t,e){const r=new Error(`deferred error during ABI decoding triggered accessing ${t}`);return r.error=e,r}class w{constructor(t){let e=[];e="string"===typeof t?JSON.parse(t):t,(0,h.zG)(this,"fragments",e.map((t=>g.HY.from(t))).filter((t=>null!=t))),(0,h.zG)(this,"_abiCoder",(0,h.tu)(new.target,"getAbiCoder")()),(0,h.zG)(this,"functions",{}),(0,h.zG)(this,"errors",{}),(0,h.zG)(this,"events",{}),(0,h.zG)(this,"structs",{}),this.fragments.forEach((t=>{let e=null;switch(t.type){case"constructor":return this.deploy?void p.warn("duplicate definition - constructor"):void(0,h.zG)(this,"deploy",t);case"function":e=this.functions;break;case"event":e=this.events;break;case"error":e=this.errors;break;default:return}let r=t.format();e[r]?p.warn("duplicate definition - "+r):e[r]=t})),this.deploy||(0,h.zG)(this,"deploy",g.Xg.from({payable:!1,type:"constructor"})),(0,h.zG)(this,"_isInterface",!0)}format(t){t||(t=g.pc.full),t===g.pc.sighash&&p.throwArgumentError("interface does not support formatting sighash","format",t);const e=this.fragments.map((e=>e.format(t)));return t===g.pc.json?JSON.stringify(e.map((t=>JSON.parse(t)))):e}static getAbiCoder(){return u.$}static getAddress(t){return(0,n.Kn)(t)}static getSighash(t){return(0,i.p3)(c(t.format()),0,4)}static getEventTopic(t){return c(t.format())}getFunction(t){if((0,i.A7)(t)){for(const e in this.functions)if(t===this.getSighash(e))return this.functions[e];p.throwArgumentError("no matching function","sighash",t)}if(-1===t.indexOf("(")){const e=t.trim(),r=Object.keys(this.functions).filter((t=>t.split("(")[0]===e));return 0===r.length?p.throwArgumentError("no matching function","name",e):r.length>1&&p.throwArgumentError("multiple matching functions","name",e),this.functions[r[0]]}const e=this.functions[g.YW.fromString(t).format()];return e||p.throwArgumentError("no matching function","signature",t),e}getEvent(t){if((0,i.A7)(t)){const e=t.toLowerCase();for(const t in this.events)if(e===this.getEventTopic(t))return this.events[t];p.throwArgumentError("no matching event","topichash",e)}if(-1===t.indexOf("(")){const e=t.trim(),r=Object.keys(this.events).filter((t=>t.split("(")[0]===e));return 0===r.length?p.throwArgumentError("no matching event","name",e):r.length>1&&p.throwArgumentError("multiple matching events","name",e),this.events[r[0]]}const e=this.events[g.QV.fromString(t).format()];return e||p.throwArgumentError("no matching event","signature",t),e}getError(t){if((0,i.A7)(t)){const e=(0,h.tu)(this.constructor,"getSighash");for(const r in this.errors){if(t===e(this.errors[r]))return this.errors[r]}p.throwArgumentError("no matching error","sighash",t)}if(-1===t.indexOf("(")){const e=t.trim(),r=Object.keys(this.errors).filter((t=>t.split("(")[0]===e));return 0===r.length?p.throwArgumentError("no matching error","name",e):r.length>1&&p.throwArgumentError("multiple matching errors","name",e),this.errors[r[0]]}const e=this.errors[g.YW.fromString(t).format()];return e||p.throwArgumentError("no matching error","signature",t),e}getSighash(t){if("string"===typeof t)try{t=this.getFunction(t)}catch(e){try{t=this.getError(t)}catch(r){throw e}}return(0,h.tu)(this.constructor,"getSighash")(t)}getEventTopic(t){return"string"===typeof t&&(t=this.getEvent(t)),(0,h.tu)(this.constructor,"getEventTopic")(t)}_decodeParams(t,e){return this._abiCoder.decode(t,e)}_encodeParams(t,e){return this._abiCoder.encode(t,e)}encodeDeploy(t){return this._encodeParams(this.deploy.inputs,t||[])}decodeErrorResult(t,e){"string"===typeof t&&(t=this.getError(t));const r=(0,i.lE)(e);return(0,i.Dv)(r.slice(0,4))!==this.getSighash(t)&&p.throwArgumentError(`data signature does not match error ${t.name}.`,"data",(0,i.Dv)(r)),this._decodeParams(t.inputs,r.slice(4))}encodeErrorResult(t,e){return"string"===typeof t&&(t=this.getError(t)),(0,i.Dv)((0,i.zo)([this.getSighash(t),this._encodeParams(t.inputs,e||[])]))}decodeFunctionData(t,e){"string"===typeof t&&(t=this.getFunction(t));const r=(0,i.lE)(e);return(0,i.Dv)(r.slice(0,4))!==this.getSighash(t)&&p.throwArgumentError(`data signature does not match function ${t.name}.`,"data",(0,i.Dv)(r)),this._decodeParams(t.inputs,r.slice(4))}encodeFunctionData(t,e){return"string"===typeof t&&(t=this.getFunction(t)),(0,i.Dv)((0,i.zo)([this.getSighash(t),this._encodeParams(t.inputs,e||[])]))}decodeFunctionResult(t,e){"string"===typeof t&&(t=this.getFunction(t));let r=(0,i.lE)(e),n=null,s="",o=null,a=null,c=null;switch(r.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(t.outputs,r)}catch(h){}break;case 4:{const t=(0,i.Dv)(r.slice(0,4)),e=v[t];if(e)o=this._abiCoder.decode(e.inputs,r.slice(4)),a=e.name,c=e.signature,e.reason&&(n=o[0]),"Error"===a?s=`; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}`:"Panic"===a&&(s=`; VM Exception while processing transaction: reverted with panic code ${o[0]}`);else try{const e=this.getError(t);o=this._abiCoder.decode(e.inputs,r.slice(4)),a=e.name,c=e.format()}catch(h){}break}}return p.throwError("call revert exception"+s,d.Yd.errors.CALL_EXCEPTION,{method:t.format(),data:(0,i.Dv)(e),errorArgs:o,errorName:a,errorSignature:c,reason:n})}encodeFunctionResult(t,e){return"string"===typeof t&&(t=this.getFunction(t)),(0,i.Dv)(this._abiCoder.encode(t.outputs,e||[]))}encodeFilterTopics(t,e){"string"===typeof t&&(t=this.getEvent(t)),e.length>t.inputs.length&&p.throwError("too many arguments for "+t.format(),d.Yd.errors.UNEXPECTED_ARGUMENT,{argument:"values",value:e});let r=[];t.anonymous||r.push(this.getEventTopic(t));const n=(t,e)=>"string"===t.type?c(e):"bytes"===t.type?(0,o.w)((0,i.Dv)(e)):("bool"===t.type&&"boolean"===typeof e&&(e=e?"0x01":"0x00"),t.type.match(/^u?int/)&&(e=s.O$.from(e).toHexString()),"address"===t.type&&this._abiCoder.encode(["address"],[e]),(0,i.$m)((0,i.Dv)(e),32));for(e.forEach(((e,s)=>{let i=t.inputs[s];i.indexed?null==e?r.push(null):"array"===i.baseType||"tuple"===i.baseType?p.throwArgumentError("filtering with tuples or arrays not supported","contract."+i.name,e):Array.isArray(e)?r.push(e.map((t=>n(i,t)))):r.push(n(i,e)):null!=e&&p.throwArgumentError("cannot filter non-indexed parameters; must be null","contract."+i.name,e)}));r.length&&null===r[r.length-1];)r.pop();return r}encodeEventLog(t,e){"string"===typeof t&&(t=this.getEvent(t));const r=[],n=[],s=[];return t.anonymous||r.push(this.getEventTopic(t)),e.length!==t.inputs.length&&p.throwArgumentError("event arguments/values mismatch","values",e),t.inputs.forEach(((t,i)=>{const a=e[i];if(t.indexed)if("string"===t.type)r.push(c(a));else if("bytes"===t.type)r.push((0,o.w)(a));else{if("tuple"===t.baseType||"array"===t.baseType)throw new Error("not implemented");r.push(this._abiCoder.encode([t.type],[a]))}else n.push(t),s.push(a)})),{data:this._abiCoder.encode(n,s),topics:r}}decodeEventLog(t,e,r){if("string"===typeof t&&(t=this.getEvent(t)),null!=r&&!t.anonymous){let e=this.getEventTopic(t);(0,i.A7)(r[0],32)&&r[0].toLowerCase()===e||p.throwError("fragment/topic mismatch",d.Yd.errors.INVALID_ARGUMENT,{argument:"topics[0]",expected:e,value:r[0]}),r=r.slice(1)}let n=[],s=[],o=[];t.inputs.forEach(((t,e)=>{t.indexed?"string"===t.type||"bytes"===t.type||"tuple"===t.baseType||"array"===t.baseType?(n.push(g._R.fromObject({type:"bytes32",name:t.name})),o.push(!0)):(n.push(t),o.push(!1)):(s.push(t),o.push(!1))}));let a=null!=r?this._abiCoder.decode(n,(0,i.zo)(r)):null,c=this._abiCoder.decode(s,e,!0),h=[],u=0,l=0;t.inputs.forEach(((t,e)=>{if(t.indexed)if(null==a)h[e]=new y({_isIndexed:!0,hash:null});else if(o[e])h[e]=new y({_isIndexed:!0,hash:a[l++]});else try{h[e]=a[l++]}catch(r){h[e]=r}else try{h[e]=c[u++]}catch(r){h[e]=r}if(t.name&&null==h[t.name]){const r=h[e];r instanceof Error?Object.defineProperty(h,t.name,{enumerable:!0,get:()=>{throw b(`property ${JSON.stringify(t.name)}`,r)}}):h[t.name]=r}}));for(let i=0;i<h.length;i++){const t=h[i];t instanceof Error&&Object.defineProperty(h,i,{enumerable:!0,get:()=>{throw b(`index ${i}`,t)}})}return Object.freeze(h)}parseTransaction(t){let e=this.getFunction(t.data.substring(0,10).toLowerCase());return e?new f({args:this._abiCoder.decode(e.inputs,"0x"+t.data.substring(10)),functionFragment:e,name:e.name,signature:e.format(),sighash:this.getSighash(e),value:s.O$.from(t.value||"0")}):null}parseLog(t){let e=this.getEvent(t.topics[0]);return!e||e.anonymous?null:new m({eventFragment:e,name:e.name,signature:e.format(),topic:this.getEventTopic(e),args:this.decodeEventLog(e,t.data,t.topics)})}parseError(t){const e=(0,i.Dv)(t);let r=this.getError(e.substring(0,10).toLowerCase());return r?new E({args:this._abiCoder.decode(r.inputs,"0x"+e.substring(10)),errorFragment:r,name:r.name,signature:r.format(),sighash:this.getSighash(r)}):null}static isInterface(t){return!(!t||!t._isInterface)}}}}]);